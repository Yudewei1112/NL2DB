**优化后的 NL2DB 应用流程（处理多 Sheet Excel 并映射到数据库）：**

1.  **传入 Excel 电子表格。**
2.  **将 Excel 电子表格用 pandas 处理，转换为 SQLite 数据库表，并保存到 SQLite 文件中。**
    * 使用 `pandas` 读取 Excel 文件的所有 Sheets。
    * 为每个 Sheet 创建对应的数据库表，表名基于excel名+ Sheet 名。
    * 建立 **Excel Sheet 名称** 到 **SQLite 数据库表名** 的映射关系。
3.  **识别每个 Excel Sheet 的表头、关键信息并向量化，识别列名映射关系：**
    * 对于 Excel 文件中的每个 Sheet：
        * 使用大模型和 Prompt 识别该 Sheet 的表头（可能包含多行）。
        * 识别该 Sheet 的关键信息（如日期范围、产品名称等）。
        * 将 Sheet 名称、识别出的表头信息、关键信息组合成文本进行向量化。
        * 存储 Sheet（及其对应的 Excel 文件名和 Sheet 名）的向量表示，并关联到原始表头信息以及对应的数据库表名。
        * 识别列名映射关系：excel文件的第一行内容是列名，由大模型提取的表头的业务含义，将两者建立映射关系，输出。
        * 保存列名—业务含义映射配置文件。
4.  **根据用户的问题 (query)，使用向量查询并召回排名前 N=5 的 Excel Sheets：**
    * 将用户的问题 (query) 向量化。
    * 使用向量相似度搜索，从存储的 Excel Sheet 向量中召回最相关的 N=5 个 Sheets（及其对应的 Excel 文件和 Sheet 名）。
5.  **使用 Rerank 模型对召回的 Excel Sheets 进行重排序，取前 K=3 个：**
    * 使用 Rerank 模型，根据用户的问题和召回的 Excel Sheets（的 Sheet 名和表头），对它们的相关性进行更精确的评估和排序。
    * 选择排名靠前的 K=3 个 Excel Sheets（及其对应的 Excel 文件和 Sheet 名）。
6.  **映射到数据库表并构建 SQL 查询：**
    * 对于前 K 个召回的 Excel Sheets，使用之前建立的映射关系，找到它们对应的 SQLite 数据库表名。
    * 将用户的问题以及这些相关的数据库表名和它们的列名（作为 Schema 信息）提供给大模型。
    + 因为数据库列名可能为空，类似于"Unnamed:0","Unnamed:1"这种，所以在大模型生成SQL语句时，需要用到列名映射为业务含义的配置文件，才能生成正确的SQL语句。
    * 指示大模型根据这些信息生成 SQL 查询语句。
7.  **查询数据库表，得到结果：**
    * 连接到 SQLite 数据库。
    * 执行生成的 SQL 查询，从对应的数据库表中获取结果。
8.  **将结果作为上下文 (context) 和用户的问题 (query) 以及相关的表结构信息结合生成 prompt，给到大模型：**
    * 构建一个 Prompt，包含用户的问题、数据库查询结果以及相关表的列名（可能需要回溯到原始 Excel 的表头信息以获得更丰富的上下文）。
    * 指示大模型根据这些信息生成自然语言的最终答案。
9.  **得到大模型的最终答案。**


